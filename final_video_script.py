from manim import *
import os # 导入 os 以便 add_sound 可以使用
import numpy as np # AI 可能会用到 numpy

# 这是一个由 AI 助手 (Qwen) 动态生成的 Manim 脚本
# 它是基于 plan.json 和以下音频时长生成的：
# [
#   {
#     "id": "b1",
#     "file": "b1.mp3",
#     "duration": 20.0
#   },
#   {
#     "id": "b2",
#     "file": "b2.mp3",
#     "duration": 18.0
#   },
#   {
#     "id": "b3",
#     "file": "b3.mp3",
#     "duration": 16.0
#   },
#   {
#     "id": "b4",
#     "file": "b4.mp3",
#     "duration": 22.0
#   },
#   {
#     "id": "b5",
#     "file": "b5.mp3",
#     "duration": 20.0
#   },
#   {
#     "id": "b6",
#     "file": "b6.mp3",
#     "duration": 18.0
#   },
#   {
#     "id": "b7",
#     "file": "b7.mp3",
#     "duration": 25.0
#   }
# ]

# 确保您已安装中文字体: Heiti SC
CN_FONT = "Heiti SC"
AUDIO_DIR = "media/sounds"

# 自动配置一个支持中文的 xelatex 模板 (用于 Tex)
XELATEX_TEMPLATE = TexTemplate(
    tex_compiler="xelatex",
    output_format=".xdv",
    preamble=r"\usepackage[UTF8]{ctex} \usepackage{amsmath} \usepackage{amssymb}"
)

class AutoGeneratedScene(Scene):
    def construct(self):
        # Mobject 跟踪器，用于在步骤间传递对象
        mobjects_on_screen = {}

        self.add_sound("media/sounds/b1.mp3")
        # 清除上一节的板书，保留图形
        self.play(FadeOut(mobjects_on_screen.get('current_board_text', VGroup())), run_time=1.0)

        # ====== 可视化区 (左侧) ======
        # 创建坐标轴和椭圆 C: x^2/12 + y^2/4 = 1
        axes = Axes(
            x_range=[-4, 4, 1],
            y_range=[-3, 3, 1],
            axis_config={"include_tip": False, "font_size": 18},
            x_length=6,
            y_length=5
        )
        ellipse = Ellipse(width=2*np.sqrt(12), height=4, color=BLUE, stroke_width=2)  # a^2=12, b^2=4
        p_dot = Dot(axes.c2p(0, 2), color=YELLOW)

        # 将图形组合并靠左对齐
        axes_group = VGroup(axes, ellipse, p_dot).to_edge(LEFT, buff=0.5).scale(0.9)
        self.play(Create(axes), Create(ellipse), Create(p_dot), run_time=2.0)

        # 保存状态
        mobjects_on_screen['axes'] = axes
        mobjects_on_screen['ellipse'] = ellipse
        mobjects_on_screen['p_dot'] = p_dot

        # ====== 板书区 (右侧) ======
        b_title = Text(r"【b1】读题与关键信息", font=CN_FONT, weight=BOLD, font_size=36)
        b_line1 = Tex(r"$	ext{椭圆 } C: \frac{x^2}{a^2} + \frac{y^2}{b^2} = 1$，$a > b > 0$", tex_template=XELATEX_TEMPLATE, font_size=38)
        b_line2 = Tex(r"离心率 $e = \frac{\sqrt{6}}{3}$，点 $P(0,2) \in C$", tex_template=XELATEX_TEMPLATE, font_size=38)
        b_line3 = Tex(r"过 $P$ 作两弦 $PA, PB$，满足 $k_{PA} + k_{PB} = 4k_{AB} \neq 0$", tex_template=XELATEX_TEMPLATE, font_size=38)
        b_line4 = Tex(r"目标：(1) 求方程；(2) 证 $AB$ 过定点；(3) 求四边形 $F_1AF_2B$ 面积范围", tex_template=XELATEX_TEMPLATE, font_size=38)

        board_group = VGroup(b_title, b_line1, b_line2, b_line3, b_line4).arrange(DOWN, aligned_edge=LEFT, buff=0.3).to_edge(RIGHT, buff=0.5).scale(0.8)

        # 逐行写入板书
        self.play(Write(b_title), run_time=1.0)
        self.play(Write(b_line1), run_time=1.0)
        self.play(Write(b_line2), run_time=1.0)
        self.play(Write(b_line3), run_time=1.0)
        self.play(Write(b_line4), run_time=1.0)

        # 保存当前板书
        mobjects_on_screen['current_board_text'] = board_group

        # 计算总动画时间并等待剩余时间
        total_anim_time = 1.0 + 2.0 + 1.0*5  # FadeOut + Create + 5 Writes
        wait_time = 20.00 - total_anim_time
        if wait_time > 0:
            self.wait(wait_time)

        self.add_sound("media/sounds/b2.mp3")
        total_anim_time = 0.0

        # 清除上一节的板书（仅右侧）
        self.play(FadeOut(mobjects_on_screen.get('current_board_text', VGroup())), run_time=1.0)
        total_anim_time += 1.0

        # ====== 可视化区 (左侧) ======
        if 'axes' not in mobjects_on_screen:
            axes = Axes(
                x_range=[-4, 4, 1],
                y_range=[-3, 3, 1],
                axis_config={"include_tip": False, "font_size": 18},
                x_length=6,
                y_length=4.5
            )
            ellipse = Ellipse(width=2*np.sqrt(12), height=2*2, color=BLUE)
            p_dot = Dot(axes.c2p(0, 2), color=YELLOW)

            # 保存状态
            mobjects_on_screen['axes'] = axes
            mobjects_on_screen['ellipse'] = ellipse
            mobjects_on_screen['p_dot'] = p_dot

            axes_group = VGroup(axes, ellipse, p_dot).to_edge(LEFT, buff=0.5).scale(0.9)
            self.play(Create(axes), Create(ellipse), Create(p_dot), run_time=2.0)
            total_anim_time += 2.0
        else:
            axes = mobjects_on_screen['axes']
            ellipse = mobjects_on_screen['ellipse']
            p_dot = mobjects_on_screen['p_dot']
            axes_group = VGroup(axes, ellipse, p_dot).to_edge(LEFT, buff=0.5).scale(0.9)

        # ====== 板书区 (右侧) ======
        b_title = Text(r"【b2】(1) 求椭圆方程", font=CN_FONT, weight=BOLD, font_size=36)
        line1 = Tex(r"$P(0,2) \in C \Rightarrow \frac{4}{b^2} = 1 \Rightarrow b^2 = 4$", tex_template=XELATEX_TEMPLATE, font_size=38)
        line2 = Tex(r"$e = \frac{c}{a} = \frac{\sqrt{6}}{3} \Rightarrow c = \frac{\sqrt{6}}{3}a$", tex_template=XELATEX_TEMPLATE, font_size=38)
        line3 = Tex(r"$a^2 = b^2 + c^2 = 4 + \frac{2}{3}a^2$", tex_template=XELATEX_TEMPLATE, font_size=38)
        line4 = Tex(r"$\Rightarrow \frac{1}{3}a^2 = 4 \Rightarrow a^2 = 12$", tex_template=XELATEX_TEMPLATE, font_size=38)
        line5 = Tex(r"$\therefore C: \frac{x^2}{12} + \frac{y^2}{4} = 1$", tex_template=XELATEX_TEMPLATE, font_size=38)

        board_group = VGroup(b_title, line1, line2, line3, line4, line5).arrange(DOWN, aligned_edge=LEFT, buff=0.3).to_edge(RIGHT, buff=0.5).scale(0.8)

        # 逐行写入板书
        self.play(Write(b_title), run_time=1.0)
        total_anim_time += 1.0
        self.play(Write(line1), run_time=1.5)
        total_anim_time += 1.5
        self.play(Write(line2), run_time=1.5)
        total_anim_time += 1.5
        self.play(Write(line3), run_time=1.5)
        total_anim_time += 1.5
        self.play(Write(line4), run_time=1.5)
        total_anim_time += 1.5
        self.play(Write(line5), run_time=1.5)
        total_anim_time += 1.5

        # 保存当前板书
        mobjects_on_screen['current_board_text'] = board_group

        # 补足总时长至 18.00 秒
        wait_time = 18.00 - total_anim_time
        if wait_time > 0:
            self.wait(wait_time)

        self.add_sound("media/sounds/b3.mp3")

        # 清除上一节的板书，保留左侧图形
        self.play(FadeOut(mobjects_on_screen.get('current_board_text', VGroup())), run_time=1.0)

        # ========== 可视化区 (左侧) ==========
        # 获取已存在的坐标轴、椭圆和点P
        axes = mobjects_on_screen.get('axes')
        ellipse = mobjects_on_screen.get('ellipse')
        p_dot = mobjects_on_screen.get('p_dot')

        # 确保基础图形存在
        if axes is None or ellipse is None:
            axes = Axes(x_range=[-4, 4, 1], y_range=[-3, 3, 1], axis_config={"include_tip": False})
            ellipse = Ellipse(width=2*np.sqrt(12), height=2*2, color=BLUE)
            p_dot = Dot(axes.c2p(0, 2), color=YELLOW)
            axes_group = VGroup(axes, ellipse, p_dot).to_edge(LEFT, buff=0.5).scale(0.9)
            self.play(Create(axes), Create(ellipse), Create(p_dot), run_time=2.0)
            mobjects_on_screen['axes'] = axes
            mobjects_on_screen['ellipse'] = ellipse
            mobjects_on_screen['p_dot'] = p_dot
        else:
            axes_group = VGroup(axes, ellipse, p_dot).to_edge(LEFT, buff=0.5).scale(0.9)

        # ========== 板书区 (右侧) ==========
        b_title = Text(r"【b3】(2) 设直线 AB 并联立", font=CN_FONT, weight=BOLD)
        line1 = Tex(r"设 $AB: y = kx + m$，$k \neq 0$", tex_template=XELATEX_TEMPLATE, font_size=38)
        line2 = Tex(r"联立 $\begin{cases} \frac{x^2}{12} + \frac{y^2}{4} = 1 \\ y = kx + m \end{cases}$", tex_template=XELATEX_TEMPLATE, font_size=38)
        line3 = Tex(r"消 $y$ 得：$(1 + 3k^2)x^2 + 6kmx + 3m^2 - 12 = 0$", tex_template=XELATEX_TEMPLATE, font_size=38)
        line4 = Tex(r"$x_1 + x_2 = -\frac{6km}{1 + 3k^2},\quad x_1x_2 = \frac{3m^2 - 12}{1 + 3k^2}$", tex_template=XELATEX_TEMPLATE, font_size=38)

        board_group = VGroup(b_title, line1, line2, line3, line4).arrange(DOWN, aligned_edge=LEFT, buff=0.4).to_edge(RIGHT, buff=0.5).scale(0.8)

        # 动画：逐行写出板书
        self.play(Write(b_title), run_time=1.0)
        self.play(Write(line1), run_time=1.0)
        self.play(Write(line2), run_time=1.5)
        self.play(Write(line3), run_time=1.5)
        self.play(Write(line4), run_time=1.5)

        # 总动画时间计算
        total_anim_time = 1.0 + 1.0 + 1.0 + 1.5 + 1.5 + 1.5 + 1.5  # FadeOut + 板书动画
        wait_time = 16.00 - total_anim_time
        self.wait(wait_time)

        # 保存当前板书状态
        mobjects_on_screen['current_board_text'] = board_group

        self.add_sound("media/sounds/b4.mp3")

        # 清除上一节的板书（仅右侧）
        self.play(FadeOut(mobjects_on_screen.get('current_board_text', VGroup())), run_time=1.0)

        # ========== 可视化区 (左侧) ==========
        # 获取已有图形状态
        axes = mobjects_on_screen.get('axes')
        ellipse = mobjects_on_screen.get('ellipse')
        p_dot = mobjects_on_screen.get('p_dot')
        a_dot = mobjects_on_screen.get('a_dot')
        b_dot = mobjects_on_screen.get('b_dot')

        # 确保所有必要对象存在
        if None in [axes, ellipse, p_dot, a_dot, b_dot]:
            # 若状态缺失，重建基础图形（通常不会发生，但为鲁棒性）
            axes = Axes(x_range=[-4, 4, 1], y_range=[-3, 3, 1], axis_config={"include_tip": False})
            ellipse = Ellipse(width=2*np.sqrt(12), height=4, color=BLUE)
            p_dot = Dot(axes.c2p(0, 2), color=YELLOW)
            k_tracker = ValueTracker(1)
            m_val = -1
            def get_intersections():
                k = k_tracker.get_value()
                # 求解交点
                A = 3*k**2 + 1
                B = 6*k*m_val
                C = 3*m_val**2 - 12
                disc = B**2 - 4*A*C
                if disc <= 0:
                    return [0,0], [0,0]
                x1 = (-B + np.sqrt(disc)) / (2*A)
                x2 = (-B - np.sqrt(disc)) / (2*A)
                y1 = k*x1 + m_val
                y2 = k*x2 + m_val
                return [x1, y1], [x2, y2]
            a_dot = always_redraw(lambda: Dot(axes.c2p(*get_intersections()[0]), color=GREEN))
            b_dot = always_redraw(lambda: Dot(axes.c2p(*get_intersections()[1]), color=RED))
            dynamic_line = always_redraw(lambda: Line(
                axes.c2p(-4, k_tracker.get_value()*(-4) + m_val),
                axes.c2p(4, k_tracker.get_value()*(4) + m_val),
                color=PURPLE
            ))
            self.add(dynamic_line, a_dot, b_dot)
            fixed_dot = Dot(axes.c2p(0, -1), color=RED)
            f1_dot = Dot(axes.c2p(-np.sqrt(8), 0), color=ORANGE)
            f2_dot = Dot(axes.c2p(np.sqrt(8), 0), color=ORANGE)
            quad = always_redraw(lambda: Polygon(
                f1_dot.get_center(),
                a_dot.get_center(),
                f2_dot.get_center(),
                b_dot.get_center(),
                color=YELLOW,
                fill_opacity=0.2
            ))
            self.add(quad)
            mobjects_on_screen.update({
                'axes': axes,
                'ellipse': ellipse,
                'p_dot': p_dot,
                'k_tracker': k_tracker,
                'a_dot': a_dot,
                'b_dot': b_dot,
                'fixed_dot': fixed_dot,
                'f1_dot': f1_dot,
                'f2_dot': f2_dot,
                'quad': quad
            })

        # 将可视化元素组合并定位到左侧
        visual_group = VGroup(axes, ellipse, p_dot).to_edge(LEFT, buff=0.5).scale(0.9)
        # 注意：dynamic_line, a_dot, b_dot, quad, fixed_dot, f1_dot, f2_dot 已通过 self.add 添加，无需再 Create

        # ========== 板书区 (右侧) ==========
        title_text = Text(r"【b4】(2) 计算斜率和并化简", font=CN_FONT, weight=BOLD)
        line1 = Tex(r"$k_{PA} = \frac{y_1 - 2}{x_1} = k + \frac{m - 2}{x_1}$", tex_template=XELATEX_TEMPLATE, font_size=38)
        line2 = Tex(r"$k_{PB} = k + \frac{m - 2}{x_2}$", tex_template=XELATEX_TEMPLATE, font_size=38)
        line3 = Tex(r"$k_{PA} + k_{PB} = 2k + (m - 2)\frac{x_1 + x_2}{x_1x_2}$", tex_template=XELATEX_TEMPLATE, font_size=38)
        line4 = Tex(r"代入得：$= 2k - \frac{6km(m - 2)}{3(m^2 - 4)} = 2k - \frac{2km}{m + 2}$", tex_template=XELATEX_TEMPLATE, font_size=38)
        line5 = Tex(r"$= \frac{4k}{m + 2}$", tex_template=XELATEX_TEMPLATE, font_size=38)

        board_group = VGroup(title_text, line1, line2, line3, line4, line5).arrange(DOWN, aligned_edge=LEFT, buff=0.4).to_edge(RIGHT, buff=0.5).scale(0.8)

        # ========== 动画执行 ==========
        total_anim_time = 0.0

        # 写入标题
        self.play(Write(title_text), run_time=1.5)
        total_anim_time += 1.5

        # 写入推导步骤
        self.play(Write(line1), run_time=2.0)
        total_anim_time += 2.0
        self.play(Write(line2), run_time=1.5)
        total_anim_time += 1.5
        self.play(Write(line3), run_time=2.5)
        total_anim_time += 2.5
        self.play(Write(line4), run_time=3.0)
        total_anim_time += 3.0
        self.play(Write(line5), run_time=2.0)
        total_anim_time += 2.0

        # 演示 k 变化以呼应讲稿中的“巧妙变形”
        k_tracker = mobjects_on_screen['k_tracker']
        self.play(k_tracker.animate.set_value(-0.5), run_time=3.0)
        total_anim_time += 3.0
        self.play(k_tracker.animate.set_value(1.5), run_time=3.0)
        total_anim_time += 3.0

        # 补足总时长至 22.00 秒
        wait_time = 22.00 - total_anim_time
        if wait_time > 0:
            self.wait(wait_time)

        # 保存当前板书状态
        mobjects_on_screen['current_board_text'] = board_group

        self.add_sound("media/sounds/b5.mp3")

        # 清除上一节的板书（仅右侧）
        self.play(FadeOut(mobjects_on_screen.get('current_board_text', VGroup())), run_time=1.0)

        # === 可视化区 (左侧) ===
        # 获取已存在的坐标系、椭圆和点 P
        axes = mobjects_on_screen.get('axes')
        ellipse = mobjects_on_screen.get('ellipse')
        p_dot = mobjects_on_screen.get('p_dot')

        if axes is None or ellipse is None or p_dot is None:
            # 安全回退：重新创建基础图形
            axes = Axes(x_range=[-4, 4, 1], y_range=[-3, 3, 1], axis_config={"include_tip": False})
            ellipse = Ellipse(width=2*np.sqrt(12), height=4, color=BLUE)
            p_dot = Dot(axes.c2p(0, 2), color=YELLOW)
            axes_group = VGroup(axes, ellipse).to_edge(LEFT, buff=0.5).scale(0.9)
            self.add(axes_group, p_dot)
            mobjects_on_screen['axes'] = axes
            mobjects_on_screen['ellipse'] = ellipse
            mobjects_on_screen['p_dot'] = p_dot
        else:
            # 确保它们在场景中（但不清除）
            pass

        # 创建并保存斜率追踪器
        k_tracker = ValueTracker(1)
        mobjects_on_screen['k_tracker'] = k_tracker

        # 直线 AB: y = kx + m, 其中 m = -1
        m_val = -1

        # 定义交点计算函数
        def get_intersection_points():
            k = k_tracker.get_value()
            # 椭圆: x^2/12 + y^2/4 = 1, 直线: y = kx - 1
            # 代入得: x^2/12 + (kx-1)^2/4 = 1
            # 整理: (1 + 3k^2)x^2 - 6k x - 9 = 0
            a = 1 + 3*k**2
            b = -6*k
            c = -9
            disc = b**2 - 4*a*c
            if disc <= 0:
                return [np.array([0,0,0]), np.array([0,0,0])]
            sqrt_disc = np.sqrt(disc)
            x1 = (-b + sqrt_disc) / (2*a)
            x2 = (-b - sqrt_disc) / (2*a)
            y1 = k*x1 + m_val
            y2 = k*x2 + m_val
            return [axes.c2p(x1, y1), axes.c2p(x2, y2)]

        # 动态直线 AB
        dynamic_line = always_redraw(
            lambda: Line(
                axes.c2p(-4, k_tracker.get_value()*(-4) + m_val),
                axes.c2p(4, k_tracker.get_value()*(4) + m_val),
                color=GREEN
            )
        )
        mobjects_on_screen['dynamic_line'] = dynamic_line

        # 动态点 A 和 B
        a_dot = always_redraw(lambda: Dot(get_intersection_points()[0], color=RED))
        b_dot = always_redraw(lambda: Dot(get_intersection_points()[1], color=RED))
        mobjects_on_screen['a_dot'] = a_dot
        mobjects_on_screen['b_dot'] = b_dot

        # 定点 (0, -1)
        fixed_dot = Dot(axes.c2p(0, -1), color=PURPLE)
        fixed_label = Tex(r"$(0,-1)$", font_size=24).next_to(fixed_dot, DOWN, buff=0.1)

        # 添加动态对象到场景
        self.add(dynamic_line, a_dot, b_dot)

        # === 板书区 (右侧) ===
        b_title = Text(r"【b5】(2) 利用条件定 m", font=CN_FONT, weight=BOLD)
        line1 = Tex(r"题设：$k_{PA} + k_{PB} = 4k_{AB} = 4k$", tex_template=XELATEX_TEMPLATE, font_size=38)
        line2 = Tex(r"$\Rightarrow \frac{4k}{m + 2} = 4k$", tex_template=XELATEX_TEMPLATE, font_size=38)
        line3 = Tex(r"$k \neq 0 \Rightarrow \frac{1}{m + 2} = 1 \Rightarrow m = -1$", tex_template=XELATEX_TEMPLATE, font_size=38)
        line4 = Tex(r"$\therefore AB: y = kx - 1$", tex_template=XELATEX_TEMPLATE, font_size=38)
        line5 = Tex(r"恒过定点 $(0, -1)$", tex_template=XELATEX_TEMPLATE, font_size=38)

        board_group = VGroup(b_title, line1, line2, line3, line4, line5).arrange(DOWN, aligned_edge=LEFT, buff=0.3).to_edge(RIGHT, buff=0.5).scale(0.8)

        # === 动画序列 ===
        total_anim_time = 0.0

        # 写入标题
        self.play(Write(b_title), run_time=1.5)
        total_anim_time += 1.5

        # 创建定点
        self.play(Create(fixed_dot), Write(fixed_label), run_time=1.0)
        total_anim_time += 1.0

        # 写入推导过程
        self.play(Write(line1), run_time=1.5)
        total_anim_time += 1.5
        self.play(Write(line2), run_time=1.0)
        total_anim_time += 1.0
        self.play(Write(line3), run_time=1.5)
        total_anim_time += 1.5
        self.play(Write(line4), run_time=1.0)
        total_anim_time += 1.0
        self.play(Write(line5), run_time=1.0)
        total_anim_time += 1.0

        # 演示直线扫过定点
        self.play(k_tracker.animate.set_value(-1.5), run_time=2.0)
        total_anim_time += 2.0
        self.play(k_tracker.animate.set_value(0.8), run_time=2.0)
        total_anim_time += 2.0

        # 等待补足总时长
        wait_time = 20.00 - total_anim_time
        if wait_time > 0:
            self.wait(wait_time)

        # 保存当前板书
        mobjects_on_screen['current_board_text'] = board_group

        self.add_sound("media/sounds/b6.mp3")

        # 清除上一节的板书，保留左侧图形
        self.play(FadeOut(mobjects_on_screen.get('current_board_text', VGroup())), run_time=1.0)

        # === 可视化区 (左侧) ===
        axes = mobjects_on_screen.get('axes')
        ellipse = mobjects_on_screen.get('ellipse')
        k_tracker = mobjects_on_screen.get('k_tracker')
        a_dot = mobjects_on_screen.get('a_dot')
        b_dot = mobjects_on_screen.get('b_dot')

        # 创建焦点 F1, F2
        f1_dot = Dot(axes.c2p(-np.sqrt(8), 0), color=GREEN)
        f2_dot = Dot(axes.c2p(np.sqrt(8), 0), color=GREEN)

        # 动态四边形 F1-A-F2-B
        quad = always_redraw(lambda: Polygon(
            f1_dot.get_center(),
            a_dot.get_center(),
            f2_dot.get_center(),
            b_dot.get_center(),
            color=PURPLE,
            fill_opacity=0.3
        ))
        self.add(quad)  # 使用 self.add 添加 always_redraw 对象

        # 演示：改变 k 值以展示四边形变化
        self.play(Create(f1_dot), Create(f2_dot), run_time=1.5)
        self.play(k_tracker.animate.set_value(0.5), run_time=2.0)

        # === 板书区 (右侧) ===
        b_title = Text(r"【b6】(3) 四边形面积表达式", font=CN_FONT, weight=BOLD).scale(0.8)
        line1 = Tex(r"焦点：$c = \sqrt{a^2 - b^2} = \sqrt{8} = 2\sqrt{2}$", tex_template=XELATEX_TEMPLATE, font_size=38)
        line2 = Tex(r"$F_1(-2\sqrt{2}, 0),\ F_2(2\sqrt{2}, 0)$", tex_template=XELATEX_TEMPLATE, font_size=38)
        line3 = Tex(r"$|F_1F_2| = 4\sqrt{2}$", tex_template=XELATEX_TEMPLATE, font_size=38)
        line4 = Tex(r"面积 $S = \frac{1}{2} \cdot |F_1F_2| \cdot |y_1 - y_2| = 2\sqrt{2} \cdot |y_1 - y_2|$", tex_template=XELATEX_TEMPLATE, font_size=38)

        board_group = VGroup(b_title, line1, line2, line3, line4).arrange(DOWN, aligned_edge=LEFT, buff=0.4).to_edge(RIGHT, buff=0.5).scale(0.85)

        # 逐行写入板书
        self.play(Write(b_title), run_time=1.0)
        self.play(Write(line1), run_time=1.2)
        self.play(Write(line2), run_time=1.0)
        self.play(Write(line3), run_time=0.8)
        self.play(Write(line4), run_time=1.5)

        # 保存当前板书状态
        mobjects_on_screen['current_board_text'] = board_group

        # 计算总动画时间并补足等待
        total_anim_time = 1.0 + 1.5 + 2.0 + 1.0 + 1.2 + 1.0 + 0.8 + 1.5  # = 10.0 秒
        wait_time = 18.00 - total_anim_time
        self.wait(wait_time)

        self.add_sound("media/sounds/b7.mp3")

        # 清除上一节的板书，保留左侧图形
        self.play(FadeOut(mobjects_on_screen.get('current_board_text', VGroup())), run_time=1.0)

        # ====== 可视化区 (左侧) ======
        # 获取已有对象
        axes = mobjects_on_screen.get('axes')
        ellipse = mobjects_on_screen.get('ellipse')
        p_dot = mobjects_on_screen.get('p_dot')
        k_tracker = mobjects_on_screen.get('k_tracker')
        a_dot = mobjects_on_screen.get('a_dot')
        b_dot = mobjects_on_screen.get('b_dot')
        f1_dot = mobjects_on_screen.get('f1_dot')
        f2_dot = mobjects_on_screen.get('f2_dot')
        quad = mobjects_on_screen.get('quad')

        # 重新创建动态直线和点（确保状态一致）
        m_val = -1
        def get_intersection_points():
            k = k_tracker.get_value()
            if abs(k) < 1e-3:
                return [axes.c2p(0, m_val)], [axes.c2p(0, m_val)]
            x_vals = np.linspace(-np.sqrt(12) + 0.01, np.sqrt(12) - 0.01, 400)
            y_line = k * x_vals + m_val
            y_ellipse_upper = 2 * np.sqrt(1 - x_vals**2 / 12)
            y_ellipse_lower = -2 * np.sqrt(1 - x_vals**2 / 12)
            diff_upper = y_line - y_ellipse_upper
            diff_lower = y_line - y_ellipse_lower
            idx_upper = np.where(np.diff(np.sign(diff_upper)))[0]
            idx_lower = np.where(np.diff(np.sign(diff_lower)))[0]
            points = []
            for idx in idx_upper:
                x0, x1 = x_vals[idx], x_vals[idx+1]
                y0, y1 = y_line[idx], y_line[idx+1]
                points.append(axes.c2p((x0+x1)/2, (y0+y1)/2))
            for idx in idx_lower:
                x0, x1 = x_vals[idx], x_vals[idx+1]
                y0, y1 = y_line[idx], y_line[idx+1]
                points.append(axes.c2p((x0+x1)/2, (y0+y1)/2))
            if len(points) < 2:
                return [axes.c2p(0, m_val)], [axes.c2p(0, m_val)]
            return points[:2]

        dynamic_line = always_redraw(lambda: 
            Line(
                axes.c2p(-4, k_tracker.get_value()*(-4) + m_val),
                axes.c2p(4, k_tracker.get_value()*(4) + m_val),
                color=BLUE
            )
        )
        a_dot = always_redraw(lambda: Dot(get_intersection_points()[0], color=YELLOW))
        b_dot = always_redraw(lambda: Dot(get_intersection_points()[1], color=YELLOW))
        quad = always_redraw(lambda: Polygon(
            f1_dot.get_center(),
            a_dot.get_center(),
            f2_dot.get_center(),
            b_dot.get_center(),
            color=PURPLE,
            fill_opacity=0.3
        ))

        # 确保所有动态对象已添加
        if 'dynamic_line' not in mobjects_on_screen:
            self.add(dynamic_line, a_dot, b_dot, quad)
            mobjects_on_screen['dynamic_line'] = dynamic_line
            mobjects_on_screen['a_dot'] = a_dot
            mobjects_on_screen['b_dot'] = b_dot
            mobjects_on_screen['quad'] = quad

        # ====== 板书区 (右侧) ======
        b_title = Text(r"【b7】(3) 求 |y₁−y₂| 与范围", font=CN_FONT, weight=BOLD)
        b_line1 = Tex(r"将 $y = kx - 1$ 代入椭圆，消 $x$ 得关于 $y$ 的方程：", tex_template=XELATEX_TEMPLATE, font_size=38)
        b_line2 = Tex(r"$(3 + \frac{1}{k^2})y^2 + \frac{2}{k^2}y + (\frac{1}{k^2} - 12) = 0$", tex_template=XELATEX_TEMPLATE, font_size=38)
        b_line3 = Tex(r"$|y_1 - y_2| = \sqrt{(y_1 + y_2)^2 - 4y_1y_2} = \frac{12\sqrt{\frac{1}{k^2} + 4}}{3 + \frac{1}{k^2}}$", tex_template=XELATEX_TEMPLATE, font_size=38)
        b_line4 = Tex(r"令 $t = \sqrt{\frac{1}{k^2} + 4} > 2$，则 $S = 12\sqrt{2} \cdot \frac{t}{t^2 - 1}$", tex_template=XELATEX_TEMPLATE, font_size=38)
        b_line5 = Tex(r"当 $k \to 0$，$t \to \infty$，$S \to 0$？但需考虑直线与椭圆有两交点 $\Rightarrow$ 判别式 $> 0$", tex_template=XELATEX_TEMPLATE, font_size=38)
        b_line6 = Tex(r"实际 $t \in (2, 2\sqrt{3})$，$S \in \left( \frac{24\sqrt{6}}{11},\ 8\sqrt{2} \right)$", tex_template=XELATEX_TEMPLATE, font_size=38)

        board_group = VGroup(b_title, b_line1, b_line2, b_line3, b_line4, b_line5, b_line6)
        board_group.arrange(DOWN, aligned_edge=LEFT, buff=0.3).to_edge(RIGHT, buff=0.5).scale(0.75)

        # ====== 动画序列 ======
        total_anim_time = 0.0

        # 写入标题
        self.play(Write(b_title), run_time=1.5)
        total_anim_time += 1.5

        # 写入推导过程
        self.play(Write(b_line1), run_time=1.2)
        total_anim_time += 1.2
        self.play(Write(b_line2), run_time=1.5)
        total_anim_time += 1.5
        self.play(Write(b_line3), run_time=1.8)
        total_anim_time += 1.8
        self.play(Write(b_line4), run_time=1.5)
        total_anim_time += 1.5
        self.play(Write(b_line5), run_time=2.0)
        total_anim_time += 2.0
        self.play(Write(b_line6), run_time=1.8)
        total_anim_time += 1.8

        # 演示k变化对t和S的影响
        self.play(k_tracker.animate.set_value(0.1), run_time=2.0)
        total_anim_time += 2.0
        self.play(k_tracker.animate.set_value(-0.3), run_time=1.7)
        total_anim_time += 1.7

        # 等待补足总时长
        wait_time = 25.00 - total_anim_time
        if wait_time > 0:
            self.wait(wait_time)

        # 保存当前板书
        mobjects_on_screen['current_board_text'] = board_group


        # --- 脚本结束 ---
        print("AI 生成的脚本执行完毕。")
        self.play(FadeOut(mobjects_on_screen.get('current_board_text', VGroup())),
                  FadeOut(mobjects_on_screen.get('axes', VGroup())),
                  FadeOut(mobjects_on_screen.get('ellipse', VGroup())),
                  FadeOut(mobjects_on_screen.get('p_dot', VGroup())),
                  # 动态对象也需要被移除 (如果存在)
                  *[FadeOut(mob) for mob in self.mobjects if hasattr(mob, 'has_updater') and mob.has_updater()]
                  ,run_time=0.5)
        self.wait(3)
